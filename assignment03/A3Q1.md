# A3Q1

### Modified Dijkstra's Algorithm - Only modified sections are shown.

```
class Heap:
    def update (self, k) -> bool:
        if k[1] in self.__key_position:
            i = self.__key_position[k[1]]
            if self.__content[i][0] > k[0]:
                self.__content[i][0] = k[0]
                while i > 1 and self.__try_swap(i // 2, i):
                    i = i // 2
            # ===== Changed Part =======
                return True
            else:
                return False
            # ===== Changed Part =======
        else:
            if self.__size + 1 == self.__capacity:
                self.__content.extend([None] * self.__capacity)
                self.__capacity *= 2
            self.__size += 1
            i = self.__size
            self.__content[i] = k
            self.__key_position[k[1]] = i
            while i > 1 and self.__try_swap(i // 2, i):
                i = i // 2
            # ===== Changed Part =======
            return True
            # ===== Changed Part =======

vertex = set()
for u, v, w in wg:
    vertex.add(u)
    vertex.add(v)
vertex = list(vertex)

# Creating the adj list
adjlist = {u:[] for u in vertex}
for u, v, w in wg:
    # Changed 
    adjlist[u].append((v, transform_w(w)))
    adjlist[v].append((u, transform_w(w)))
print('to vertex |', end='')
for u in vertex:
    print('%4d' % u, end='   ')
print()
print('-' * 51)
# ===== Changed Part =======
# Store in the form vertex: (previous_vertex, distance)
shortest_parent = {} 
for u in vertex:
    # Shortest path from each vertex
    heap = Heap([[0, u]])
    dist = {}
    while heap.len() > 0:
        mindist, v = heap.pop()
        dist[v] = mindist
        for i, w in adjlist[v]:
            if i not in dist:
                if heap.update([mindist + w, i]):
                    # If true, this means we update the shortest path to this vertex
                    # else, we ignore
                    shortest_parent[i] = (v, mindist + w)
    # Break because we only need from the start, so only from one vertex
    break
# ===== Changed Part =======

# ===== Changed Part =======
def trace_path(start, end, shortest_parent):
    """
    Traces the path from the start to the end using the shortest_parent dictionary
    """
    path = []
    current = end
    while current != start:
        print(f"Current is {current} and start is {start}")
        path.append(current)
        current = shortest_parent[current][0]
    path.append(start)
    return path[::-1]
# ===== Changed Part =======
start = 1
end = 6
print(f"Shortest path from {start} to {end} is {trace_path(start, end, shortest_parent)}")
``` 

### Details
Things to modify from algorithm given in slides
1. Define a transformation that changes the probability of getting caught into a log probability, where a lower number corrosponds to the safest path (aka highest probability that he will not get caught.) Apply this transformation when creating the adjlist.
2. Modify the algorithm that keeps track of the shortest parent to any of the vertexes.
3. Define a function that given a start and end point, will traverse the information obtained in `2.` and return the shortest path.
4. Under custom Heap class created, modifed `Heap.update` such that if the arguments passed in indicate a shorter path, it will return `True` and `False` otherwise. This aids in updating `2.`.

# 1. Transformation
```
def transform_w(w: float) -> float:
    """
    Applies two set of transformation in the order below
    1. take 1 - w, this is to return a value of the probability of NOT being caught
    2. take natural log of the result from step 1, this is to convert it to log probabilities
    3. multiply by -1, this is to make the log probabilities positive
    This allows us to easily calculate the log probabilities of the path by summing the weights
    up. This particular transformation makes it so the smallest weight corrosponds to the lowest
    probability of being caught.
    """
    return -math.log(1 - w)
...
# Changed 
for u, v, w in wg:
    adjlist[u].append((v, transform_w(w)))
    adjlist[v].append((u, transform_w(w)))
```

# 3. Trace Path
```
def trace_path(start, end, shortest_parent):
    """
    Traces the path from the start to the end using the shortest_parent dictionary
    """
    path = []
    current = end
    while current != start:
        print(f"Current is {current} and start is {start}")
        path.append(current)
        current = shortest_parent[current][0]
    path.append(start)
    return path[::-1]
```

---

# Q1b

In order to hit a certain timing constraint `Tmax`, we will seek to modify the Shortest Path problem into a Max Flow problem by adding a Source and a Sink. Assuming the `Tmax` constraint can be fulfilled by ensuring that the `total sum of path from start to end` < `Tmax`, we create an edge from the goal node in the shortest path to the Sink with weight `Tmax`. 

Max Flow problems have an added constraint such that at each step, it will only augment the flow `f` by an amount that is the minimal of the edges. This means that the total sum of weights of the path chosen will not exceed `Tmax`, hence the path found via the Max Flow problem will be the shortest path that satisfies the constraint.

# Likely have to go into more detail