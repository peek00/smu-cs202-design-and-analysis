# A3Q1

### Dijkstra's Algorithm - heapq implementation from slides

```
heap = []
for v in vertex:
    if v! = u:
        heapq.heappush(heap,
                        [ adj[u][v] if v in adj[u] else float('inf), v ]
                        )

dist = {u: 0}
while len(heap) > 0:
    minddist, v = heapq.heappop(heap)
    dist[v] = mindist
    for i in range(len(heap)):
        if heap[i][1] in adj[v]:
            heap[i][0] = min(heap[i][0], mindist + adj[v][heap[i][1]])
    heapq.heapify(heap)
``` 

### Modified Version
Given a undirected graph (V,E) where V is the set of street intersections aka vertexs and E is the street joining two intersections aka edges with `p(u,v)` denoting the probability that Tom Bruce might be caught on the street, 
find the safe path aka lowest combined probability that Tom can get to the end point. 

Things to modify from algorithm given in slides
1. Modify the distance algorithm
> a. Use log probabilities instead, using natural log e, referred to as `ln`
2. Retrieve back the shortest path

Preprocessing steps

1. Assuming adj[u][v] has already been created given (u,v), and there are no edges with a 100% probability of being caught.
2. Loop through all entries in adj[u][v] and apply the following steps
```
# Modify the entries in adj matrix to use ln(1-adj[u][v]) to get the ln probability of not getting caught.

heap = []
for v in vertex:
    if v! = u:
        heapq.heappush(heap,
                        [ adj[u][v] if v in adj[u] else float('inf), v ]
                        )

dist = {u: 0}
while len(heap) > 0:
    minddist, v = heapq.heappop(heap)
    dist[v] = mindist
    for i in range(len(heap)):
        if heap[i][1] in adj[v]:
            heap[i][0] = min(heap[i][0], mindist + adj[v][heap[i][1]])
    heapq.heapify(heap)

```